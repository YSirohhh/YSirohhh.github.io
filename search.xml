<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>sm3算法实现</title>
      <link href="/sm3%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/sm3%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  宏定义部分（循环左移、置换函数 P0 / P1）</span></span><br><span class="line"><span class="comment">// 循环左移（x 循环左移 n 位）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROTL(x, n) (((x) <span class="string">&lt;&lt; (n)) | ((x) &gt;</span>&gt; (32 - (n))))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// P0 置换函数：P0(X) = X ^ (X&lt;&lt;&lt;9) ^ (X&lt;&lt;&lt;17)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P0(x) ((x) ^ ROTL((x), 9) ^ ROTL((x), 17))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// P1 置换函数：P1(X) = X ^ (X&lt;&lt;&lt;15) ^ (X&lt;&lt;&lt;23)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P1(x) ((x) ^ ROTL((x), 15) ^ ROTL((x), 23))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  IV 初始向量（SM3 标准固定）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始向量 V0</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> IV[<span class="number">8</span>] = &#123;</span><br><span class="line">    <span class="number">0x7380166fU</span>L, <span class="number">0x4914b2b9U</span>L, <span class="number">0x172442d7U</span>L, <span class="number">0xda8a0600U</span>L,</span><br><span class="line">    <span class="number">0xa96f30bcU</span>L, <span class="number">0x163138aaU</span>L, <span class="number">0xe38dee4dU</span>L, <span class="number">0xb0fb0e4eU</span>L&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  常量 Tj（第 j 轮使用的常数）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// j = 0..15 使用</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> Tj_base0 = <span class="number">0x79cc4519U</span>L;</span><br><span class="line"></span><br><span class="line"><span class="comment">// j = 16..63 使用</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> Tj_base1 = <span class="number">0x7a879d8aU</span>L;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  布尔函数 FFj（随 j 改变）</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">FFj</span><span class="params">(<span class="type">uint32_t</span> x, <span class="type">uint32_t</span> y, <span class="type">uint32_t</span> z, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 第 0~15 轮：FF = X ^ Y ^ Z</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; j &lt;= <span class="number">15</span>)</span><br><span class="line">        <span class="keyword">return</span> x ^ y ^ z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 16~63 轮：FF = (X &amp; Y) | (X &amp; Z) | (Y &amp; Z)</span></span><br><span class="line">    <span class="keyword">return</span> (x &amp; y) | (x &amp; z) | (y &amp; z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  布尔函数 GGj（随 j 改变）</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">GGj</span><span class="params">(<span class="type">uint32_t</span> x, <span class="type">uint32_t</span> y, <span class="type">uint32_t</span> z, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 第 0~15 轮：GG = X ^ Y ^ Z</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; j &lt;= <span class="number">15</span>)</span><br><span class="line">        <span class="keyword">return</span> x ^ y ^ z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 16~63 轮：GG = (X &amp; Y) | ((~X) &amp; Z)</span></span><br><span class="line">    <span class="keyword">return</span> (x &amp; y) | ((~x) &amp; z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  大端序读取和写入 32 位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从大端字节序读取一个 32 位整数</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">GETU32_BE</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">uint32_t</span>)b[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">           ((<span class="type">uint32_t</span>)b[<span class="number">1</span>] &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">           ((<span class="type">uint32_t</span>)b[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">           (<span class="type">uint32_t</span>)b[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个 32 位整数为大端序</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">PUTU32_BE</span><span class="params">(<span class="type">uint8_t</span> *b, <span class="type">uint32_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    b[<span class="number">0</span>] = (<span class="type">uint8_t</span>)(v &gt;&gt; <span class="number">24</span>);</span><br><span class="line">    b[<span class="number">1</span>] = (<span class="type">uint8_t</span>)(v &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    b[<span class="number">2</span>] = (<span class="type">uint8_t</span>)(v &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    b[<span class="number">3</span>] = (<span class="type">uint8_t</span>)(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  压缩函数（SM3 的核心）</span></span><br><span class="line"><span class="comment">// V 为 256位中间向量，block 为 512bit 数据块（64 字节）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sm3_compress</span><span class="params">(<span class="type">uint32_t</span> V[<span class="number">8</span>], <span class="type">const</span> <span class="type">uint8_t</span> block[<span class="number">64</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> W[<span class="number">68</span>];  <span class="comment">// 消息扩展数组 W0..W67</span></span><br><span class="line">    <span class="type">uint32_t</span> W1[<span class="number">64</span>]; <span class="comment">// W1[j] = W[j] ^ W[j+4]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  1. 消息扩展 （根据 SM3 标准）</span></span><br><span class="line">    <span class="comment">// 前 16 个字直接取原始消息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        W[j] = GETU32_BE(block + j * <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展 W[16..67]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">16</span>; j &lt; <span class="number">68</span>; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> x = W[j - <span class="number">16</span>] ^ W[j - <span class="number">9</span>] ^ ROTL(W[j - <span class="number">3</span>], <span class="number">15</span>);</span><br><span class="line">        W[j] = P1(x) ^ ROTL(W[j - <span class="number">13</span>], <span class="number">7</span>) ^ W[j - <span class="number">6</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 W1 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        W1[j] = W[j] ^ W[j + <span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2. 初始化寄存器  (A,B,C,D,E,F,G,H)</span></span><br><span class="line">    <span class="type">uint32_t</span> A = V[<span class="number">0</span>], B = V[<span class="number">1</span>], C = V[<span class="number">2</span>], D = V[<span class="number">3</span>];</span><br><span class="line">    <span class="type">uint32_t</span> E = V[<span class="number">4</span>], F = V[<span class="number">5</span>], G = V[<span class="number">6</span>], H = V[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3. 进行 64 轮压缩</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> Tj = (j &lt;= <span class="number">15</span>) ? Tj_base0 : Tj_base1; <span class="comment">// 选择对应的 Tj</span></span><br><span class="line">        <span class="type">uint32_t</span> T_rot = ROTL(Tj, j &amp; <span class="number">31</span>);             <span class="comment">// Tj 循环左移 j 位</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// SS1 = ((A&lt;&lt;&lt;12) + E + (Tj&lt;&lt;&lt;j)) &lt;&lt;&lt; 7</span></span><br><span class="line">        <span class="type">uint32_t</span> SS1 = ROTL((ROTL(A, <span class="number">12</span>) + E + T_rot), <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SS2 = SS1 ^ (A&lt;&lt;&lt;12)</span></span><br><span class="line">        <span class="type">uint32_t</span> SS2 = SS1 ^ ROTL(A, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TT1 = FF(A,B,C) + D + SS2 + W1[j]</span></span><br><span class="line">        <span class="type">uint32_t</span> TT1 = (FFj(A, B, C, j) + D + SS2 + W1[j]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TT2 = GG(E,F,G) + H + SS1 + W[j]</span></span><br><span class="line">        <span class="type">uint32_t</span> TT2 = (GGj(E, F, G, j) + H + SS1 + W[j]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寄存器更新（按标准）</span></span><br><span class="line">        D = C;</span><br><span class="line">        C = ROTL(B, <span class="number">9</span>);</span><br><span class="line">        B = A;</span><br><span class="line">        A = TT1;</span><br><span class="line"></span><br><span class="line">        H = G;</span><br><span class="line">        G = ROTL(F, <span class="number">19</span>);</span><br><span class="line">        F = E;</span><br><span class="line">        E = P0(TT2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  4. 最终向量 V = V ⊕ ABCDEFGH</span></span><br><span class="line">    V[<span class="number">0</span>] ^= A;</span><br><span class="line">    V[<span class="number">1</span>] ^= B;</span><br><span class="line">    V[<span class="number">2</span>] ^= C;</span><br><span class="line">    V[<span class="number">3</span>] ^= D;</span><br><span class="line">    V[<span class="number">4</span>] ^= E;</span><br><span class="line">    V[<span class="number">5</span>] ^= F;</span><br><span class="line">    V[<span class="number">6</span>] ^= G;</span><br><span class="line">    V[<span class="number">7</span>] ^= H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  SM3 哈希函数入口</span></span><br><span class="line"><span class="comment">// msg: 输入消息</span></span><br><span class="line"><span class="comment">// msglen: 消息长度</span></span><br><span class="line"><span class="comment">// out[32]: 输出 32 字节哈希值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sm3_hash</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *msg, <span class="type">size_t</span> msglen, <span class="type">uint8_t</span> out[<span class="number">32</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  1. 填充消息 （标准 padding）</span></span><br><span class="line">    <span class="type">uint64_t</span> bitlen = (<span class="type">uint64_t</span>)msglen * <span class="number">8ULL</span>; <span class="comment">// 原文 bit 长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算填充 0 的数量：保证末尾剩下 8 字节存放长度</span></span><br><span class="line">    <span class="type">size_t</span> k = (<span class="number">56</span> - (msglen + <span class="number">1</span>) % <span class="number">64</span>) % <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总 padding 长度 = 0x80 + k 个 0x00 + 8 字节长度</span></span><br><span class="line">    <span class="type">size_t</span> padlen = <span class="number">1</span> + k + <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充后的总长度</span></span><br><span class="line">    <span class="type">size_t</span> total = msglen + padlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="type">uint8_t</span> *buf = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(total);</span><br><span class="line">    <span class="keyword">if</span> (!buf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制原文</span></span><br><span class="line">    <span class="built_in">memcpy</span>(buf, msg, msglen);</span><br><span class="line">    buf[msglen] = <span class="number">0x80</span>; <span class="comment">// 添加 0x80</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// k 个 0x00</span></span><br><span class="line">    <span class="keyword">if</span> (k)</span><br><span class="line">        <span class="built_in">memset</span>(buf + msglen + <span class="number">1</span>, <span class="number">0</span>, k);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入 64bit 大端序长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[msglen + <span class="number">1</span> + k + i] = (<span class="type">uint8_t</span>)(bitlen &gt;&gt; (<span class="number">56</span> - <span class="number">8</span> * i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2. 按每 64 字节一块进行压缩</span></span><br><span class="line">    <span class="type">uint32_t</span> V[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        V[i] = IV[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> blocks = total / <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; blocks; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sm3_compress(V, buf + i * <span class="number">64</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3. 输出哈希值（大端）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        PUTU32_BE(out + i * <span class="number">4</span>, V[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  打印十六进制</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_hex</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *buf, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x&quot;</span>, buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  主函数示例</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">1024</span>]; <span class="comment">// 允许输入最长 1023 字符</span></span><br><span class="line">    <span class="type">uint8_t</span> digest[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要进行 SM3 的字符串（可为空）：\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 fgets 读取用户输入（可为空）</span></span><br><span class="line">    <span class="keyword">if</span> (!fgets(input, <span class="keyword">sizeof</span>(input), <span class="built_in">stdin</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;读取输入失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去掉末尾的换行符</span></span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">strlen</span>(input);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span> &amp;&amp; input[len - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        input[len - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 SM3</span></span><br><span class="line">    sm3_hash((<span class="type">const</span> <span class="type">uint8_t</span> *)input, <span class="built_in">strlen</span>(input), digest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sm3(\&quot;%s\&quot;) = &quot;</span>, input);</span><br><span class="line">    print_hex(digest, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h1><h2 id="消息填充模块"><a href="#消息填充模块" class="headerlink" title="消息填充模块"></a>消息填充模块</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm3_hash(<span class="type">const</span> <span class="type">uint8_t</span> *msg, <span class="type">size_t</span> msglen, <span class="type">uint8_t</span> out[<span class="number">32</span>])</span><br></pre></td></tr></table></figure><p>实际上相当于<strong>函数入口</strong><br><code>msg</code>代表输入信息<br><code>msglen</code>代表消息长度<br><code>out</code>代表将要输出的256位的sm3杂凑值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> bitlen = (<span class="type">uint64_t</span>)msglen * <span class="number">8ULL</span>; <span class="comment">// 原文 bit 长度</span></span><br></pre></td></tr></table></figure><p><code>bitlen</code>用于存储原文长度，<code>uint64_t</code>代表类型为64位无符号整数，因为SM3 标准规定：消息长度使用 64 位存储，不能多也不能少<br><code>(uint64_t)msglen</code>用于将<code>msglen</code>显式转换为<code>uint64_t</code>类型<br><code>msglen</code>代表输入消息的字节长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> k = (<span class="number">56</span> - (msglen + <span class="number">1</span>) % <span class="number">64</span>) % <span class="number">64</span>;</span><br></pre></td></tr></table></figure><p><code>k</code>表示需要填充的0的数量,前面说过需要填充0使得<code>l+1+k≡448(mod 512)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> padlen = <span class="number">1</span> + k + <span class="number">8</span>;</span><br><span class="line"><span class="type">size_t</span> total = msglen + padlen;</span><br></pre></td></tr></table></figure><p><code>padlen</code>代表了总共需要在原来输入中添加多少字节(1字节&#x3D;8位)<br><code>total</code>即为输入长度+填充长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> *buf = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(total);</span><br><span class="line"><span class="built_in">memcpy</span>(buf, msg, msglen);</span><br><span class="line">buf[msglen] = <span class="number">0x80</span>;</span><br><span class="line"><span class="built_in">memset</span>(buf + msglen + <span class="number">1</span>, <span class="number">0</span>, k);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    buf[msglen + <span class="number">1</span> + k + i] = (<span class="type">uint8_t</span>)(bitlen &gt;&gt; (<span class="number">56</span> - <span class="number">8</span> * i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buf填充的具体步骤如下:</p><ol><li>给<code>buf</code>分配总共需要的大小，用于存储填充后的完整消息</li><li>将原始信息<code>msg</code>输入到<code>buf</code>中</li><li>在<code>buf</code>中填充1(还要附加7个0组成一字节,但不可能越界,因为一个字符占8位)</li><li>将需要填充的0填入<code>buf</code></li><li>将64位的长度信息填入<code>buf</code>,这里<code>buf[msglen + 1 + k + i]</code>是为了跳过原始信息长度<code>msglen</code>,1位填充位,<code>k</code>个填充0,最后的<code>+i</code>是每个长度信息的偏移量</li></ol><h2 id="消息扩展模块"><a href="#消息扩展模块" class="headerlink" title="消息扩展模块"></a>消息扩展模块</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> blocks = total / <span class="number">64</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; blocks; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    sm3_compress(V, buf + i * <span class="number">64</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将填充完毕后的信息分组,512位为1组,再让每组开始进行消息扩展</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sm3_compress</span><span class="params">(<span class="type">uint32_t</span> V[<span class="number">8</span>], <span class="type">const</span> <span class="type">uint8_t</span> block[<span class="number">64</span>])</span></span><br></pre></td></tr></table></figure><p>消息扩展函数<br><code>V</code>用于等会的压缩函数作为初始数值<br><code>block</code>即表示当前组,每组都要进行一次扩展和压缩</p><p>接下来要将消息扩展为132个32位的W(W0, W1, …, W67 和 W‘0, W’1, …, W‘63)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line">    W[j] = GETU32_BE(block + j * <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前16个W很简单,就是将分组中的内容平分位16块填入W0-W15</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">16</span>; j &lt; <span class="number">68</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> x = W[j - <span class="number">16</span>] ^ W[j - <span class="number">9</span>] ^ ROTL(W[j - <span class="number">3</span>], <span class="number">15</span>);</span><br><span class="line">    W[j] = P1(x) ^ ROTL(W[j - <span class="number">13</span>], <span class="number">7</span>) ^ W[j - <span class="number">6</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该段为W16到W67用此方法扩展,其中ROTL具体为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ROTL(x, n) (((x) <span class="string">&lt;&lt; (n)) | ((x) &gt;</span>&gt; (32 - (n))))</span></span><br></pre></td></tr></table></figure><p>其中P1具体为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> P1(x) ((x) ^ ROTL((x), 15) ^ ROTL((x), 23))</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line">W1[j] = W[j] ^ W[j + <span class="number">4</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该段为W’0 到 W’63的扩展方法,也是W比W’多4位的原因<br>至此消息扩展完成</p><h2 id="压缩函数"><a href="#压缩函数" class="headerlink" title="压缩函数"></a>压缩函数</h2><p>初始化寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> A = V[<span class="number">0</span>], B = V[<span class="number">1</span>], C = V[<span class="number">2</span>], D = V[<span class="number">3</span>];</span><br><span class="line"><span class="type">uint32_t</span> E = V[<span class="number">4</span>], F = V[<span class="number">5</span>], G = V[<span class="number">6</span>], H = V[<span class="number">7</span>];</span><br></pre></td></tr></table></figure><p>接下来的每轮压缩都会得到一个新的<code>ABCDEFGH</code>的值,直到最后一组消息分组进行完压缩,最后的<code>ABCDEFGH</code>便是消息的杂凑值</p><p>64轮迭代函数如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> Tj = (j &lt;= <span class="number">15</span>) ? Tj_base0 : Tj_base1; <span class="comment">// 选择对应的 Tj</span></span><br><span class="line">    <span class="type">uint32_t</span> T_rot = ROTL(Tj, j &amp; <span class="number">31</span>);             <span class="comment">// Tj 循环左移 j 位</span></span><br><span class="line">    <span class="comment">// SS1 = ((A&lt;&lt;&lt;12) + E + (Tj&lt;&lt;&lt;j)) &lt;&lt;&lt; 7</span></span><br><span class="line">    <span class="type">uint32_t</span> SS1 = ROTL((ROTL(A, <span class="number">12</span>) + E + T_rot), <span class="number">7</span>);</span><br><span class="line">    <span class="comment">// SS2 = SS1 ^ (A&lt;&lt;&lt;12)</span></span><br><span class="line">    <span class="type">uint32_t</span> SS2 = SS1 ^ ROTL(A, <span class="number">12</span>);</span><br><span class="line">    <span class="comment">// TT1 = FF(A,B,C) + D + SS2 + W1[j]</span></span><br><span class="line">    <span class="type">uint32_t</span> TT1 = (FFj(A, B, C, j) + D + SS2 + W1[j]);</span><br><span class="line">    <span class="comment">// TT2 = GG(E,F,G) + H + SS1 + W[j]</span></span><br><span class="line">    <span class="type">uint32_t</span> TT2 = (GGj(E, F, G, j) + H + SS1 + W[j]);</span><br><span class="line">    <span class="comment">// 寄存器更新（按标准）</span></span><br><span class="line">    D = C;</span><br><span class="line">    C = ROTL(B, <span class="number">9</span>);</span><br><span class="line">    B = A;</span><br><span class="line">    A = TT1;</span><br><span class="line">    H = G;</span><br><span class="line">    G = ROTL(F, <span class="number">19</span>);</span><br><span class="line">    F = E;</span><br><span class="line">    E = P0(TT2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中,SS1,SS2,TT1,TT2都只是一个暂存的容器,<br>Tj是一个随着循环轮数变换的常数<br>具体为<code>Tj = 79cc4519 (前16轮) 或 7a879d8a (后48轮)</code><br>ROTL在前文有做过解释<br>FFj和GGj是布尔函数,具体实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">FFj</span><span class="params">(<span class="type">uint32_t</span> x, <span class="type">uint32_t</span> y, <span class="type">uint32_t</span> z, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 第 0~15 轮：FF = X ^ Y ^ Z</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; j &lt;= <span class="number">15</span>)</span><br><span class="line">        <span class="keyword">return</span> x ^ y ^ z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 16~63 轮：FF = (X &amp; Y) | (X &amp; Z) | (Y &amp; Z)</span></span><br><span class="line">    <span class="keyword">return</span> (x &amp; y) | (x &amp; z) | (y &amp; z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">GGj</span><span class="params">(<span class="type">uint32_t</span> x, <span class="type">uint32_t</span> y, <span class="type">uint32_t</span> z, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 第 0~15 轮：GG = X ^ Y ^ Z</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; j &lt;= <span class="number">15</span>)</span><br><span class="line">        <span class="keyword">return</span> x ^ y ^ z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第 16~63 轮：GG = (X &amp; Y) | ((~X) &amp; Z)</span></span><br><span class="line">    <span class="keyword">return</span> (x &amp; y) | ((~x) &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后,当各个分组做完64轮迭代后,我们便可以得到新的<code>ABCDEFGH</code>,每个变量占32位共256位,这便是最终的杂凑值</p><h2 id="整体接口"><a href="#整体接口" class="headerlink" title="整体接口"></a>整体接口</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">uint8_t</span> digest[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要进行 SM3 的字符串（可为空）：\n&quot;</span>);</span><br><span class="line">    sm3_hash((<span class="type">const</span> <span class="type">uint8_t</span> *)input, <span class="built_in">strlen</span>(input), digest);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sm3(\&quot;%s\&quot;) = &quot;</span>, input);</span><br><span class="line">    print_hex(digest, <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在整体接口中,系统会提示用户 <strong>“请输入要进行 SM3 的字符串（可为空）”</strong> ,用户需要输入最多1023个字符(也可以不输入直接计算空字符的sm3杂凑值)</p><p>接着系统调用sm3_hash来开始计算sm3杂凑值,并将结果存储到256位的结果变量digest<br>最后将输出杂凑值,此接口简单易用</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sm3案例&#39;abcd&#39;*16</title>
      <link href="/sm3%E6%A1%88%E4%BE%8B-abcd-16/"/>
      <url>/sm3%E6%A1%88%E4%BE%8B-abcd-16/</url>
      
        <content type="html"><![CDATA[<h1 id="SM3加密过程"><a href="#SM3加密过程" class="headerlink" title="SM3加密过程"></a>SM3加密过程</h1><p>以abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd为例子</p><p>字符串 “abcd*16” 的ASCII码为：<br>a &#x3D; 0x61 &#x3D; 01100001<br>b &#x3D; 0x62 &#x3D; 01100010<br>c &#x3D; 0x63 &#x3D; 01100011<br>d &#x3D; 0x64 &#x3D; 01100100</p><p>所以，”abcd x 16” 的二进制表示为：<br>01100001 01100010 01100011 01100100 (x16)<br>32 x 16 &#x3D; 512位</p><h2 id="消息填充"><a href="#消息填充" class="headerlink" title="消息填充"></a>消息填充</h2><ol><li><p><strong>添加比特1</strong><br> <strong>当前为：</strong>  01100001 01100010 01100011 01100100 (x16) 1<br> <strong>当前位数：</strong> 513 位</p><br></li><li><p><strong>补 “0”</strong> 直到长度满足 (长度 % 512) &#x3D; 448<br> 513%512 &#x3D; 1<br> <strong>当前为：</strong>  01100001 01100010 01100011 01100100 … 1 0…0000(448-1 &#x3D; 447个0)<br> <strong>当前位数：</strong> 513 + 447 &#x3D; 960位</p><br></li><li><p><strong>添加64位的长度信息</strong><br>abcd*16 共 512位，用64位标识512即0000000000000200 H<br>00000000 00000000 00000000 00000000 00000000 00000000 00000010 00000000<br><strong>当前为：</strong> 01100001 01100010 01100011 01100100 1 0…000（447个0） 0…010 0000000（64位长度表示）<br><strong>当前位数：</strong> 960 + 64 &#x3D; 1024位</p><br></li><li><p><strong>填充后消息大于512位，进行分组</strong><br>512位为一组，共B0、B1两组<br><strong>当前B0为：</strong> 01100001 01100010 01100011 01100100 (x16)<br><strong>当前B0位数为：</strong> 512位<br><strong>当前B1为：</strong> 1 0…0（447个0） 0…010 0000000（64位长度表示）<br><strong>当前B1位数为：</strong> 512位</p></li></ol><h2 id="消息扩展"><a href="#消息扩展" class="headerlink" title="消息扩展"></a>消息扩展</h2><p>B0、B1d都要扩展为（W0, W1, …, W67 和 W‘0, W’1, …, W‘63）<br>一个W占32位，共132个W</p><h3 id="先看B0"><a href="#先看B0" class="headerlink" title="先看B0"></a>先看B0</h3><h4 id="B0的前16个W（W0-15）就是填充完的消息"><a href="#B0的前16个W（W0-15）就是填充完的消息" class="headerlink" title="B0的前16个W（W0-15）就是填充完的消息"></a>B0的前16个W（W0-15）就是填充完的消息</h4><p>jWj十六进制说明<br>0W061626364“abcd”<br>1W161626364“abcd”<br>2W261626364“abcd”<br>3W361626364“abcd”<br>4W461626364“abcd”<br>5W561626364“abcd”<br>6W661626364“abcd”<br>7W761626364“abcd”<br>8W861626364“abcd”<br>9W961626364“abcd”<br>10W1061626364“abcd”<br>11W1161626364“abcd”<br>12W1261626364“abcd”<br>13W1361626364“abcd”<br>14W1461626364“abcd”<br>15W1561626364“abcd”</p><h4 id="B0的扩展生成-W16-到-W67"><a href="#B0的扩展生成-W16-到-W67" class="headerlink" title="B0的扩展生成 W16 到 W67"></a>B0的扩展生成 W16 到 W67</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOR j=16 TO 67 </span><br><span class="line">    Wj ←P1(Wj−16 ⊕Wj−9 ⊕(Wj−3 ≪15))⊕(Wj−13 ≪ 7)⊕Wj−6 </span><br><span class="line">ENDFOR</span><br></pre></td></tr></table></figure><p>其中P1具体实现为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P1(X) = X ⊕ (X ≪ 15) ⊕ (X ≪ 23)</span><br></pre></td></tr></table></figure><h4 id="B0的扩展生成-W’0-到-W’63"><a href="#B0的扩展生成-W’0-到-W’63" class="headerlink" title="B0的扩展生成 W’0 到 W’63"></a>B0的扩展生成 W’0 到 W’63</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOR j=0 TO 63</span><br><span class="line">    W′j = Wj ⊕Wj+4     //Wi与Wi+4互相异或</span><br><span class="line">ENDFOR</span><br></pre></td></tr></table></figure><p>此时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">W0W1...W67</span><br><span class="line">61626364 61626364 61626364 61626364 61626364 61626364 61626364 61626364</span><br><span class="line">61626364 61626364 61626364 61626364 61626364 61626364 61626364 61626364</span><br><span class="line">a121a024 a121a024 a121a024 6061e0e5 6061e0e5 6061e0e5 a002e345 a002e345</span><br><span class="line">a002e345 49c969ed 49c969ed 49c969ed 85ae5679 a44ff619 a44ff619 694b6244</span><br><span class="line">e8c8e0c4 e8c8e0c4 240e103e 346e603e 346e603e 9a517ab5 8a01aa25 8a01aa25</span><br><span class="line">0607191c 25f8a37a d528936a 89fbd8ae 00606206 10501256 7cff7ef9 3c78b9f9</span><br><span class="line">cc2b8a69 9f03f169 df45be20 9ec5bee1 0a212906 49ff72c0 46717241 67e09a19</span><br><span class="line">6efaa333 2ebae676 3475c386 201dcff6 2f18fccf 2c5f2b5c a80b9f38 bc139f34</span><br><span class="line">c47f18a7 a25ce71d 42743705 51baf619</span><br><span class="line"></span><br><span class="line">W′0W′1...W′63</span><br><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">00000000 00000000 00000000 00000000 c043c340 c043c340 c043c340 01038381</span><br><span class="line">c14040c1 c14040c1 01234361 c06303a0 c06303a0 29a88908 e9cb8aa8 e9cb8aa8</span><br><span class="line">25acb53c ed869ff4 ed869ff4 20820ba9 6d66b6bd 4c8716dd 8041e627 5d25027a</span><br><span class="line">dca680fa 72999a71 ae0fba1b be6fca1b 32697922 bfa9d9cf 5f29394f 03fa728b</span><br><span class="line">06677b1a 35a8b12c a9d7ed93 b5836157 cc4be86f 8f53e33f a3bac0d9 a2bd0718</span><br><span class="line">c60aa36f d6fc83a9 9934cc61 f92524f8 64db8a35 674594b6 7204b1c7 47fd55ef</span><br><span class="line">41e25ffc 02e5cd2a 9c7e5cbe 9c0e50c2 eb67e468 8e03cc41 ea7fa83d eda9692d</span><br></pre></td></tr></table></figure><h3 id="由同样的方法可以得到B1的消息扩展"><a href="#由同样的方法可以得到B1的消息扩展" class="headerlink" title="由同样的方法可以得到B1的消息扩展"></a>由同样的方法可以得到B1的消息扩展</h3><h4 id="B1的前16个W（W0-15）就是填充完的消息"><a href="#B1的前16个W（W0-15）就是填充完的消息" class="headerlink" title="B1的前16个W（W0-15）就是填充完的消息"></a>B1的前16个W（W0-15）就是填充完的消息</h4><p>j Wj 十六进制 说明<br>0 W0 80000000 首位的1 + 31个0<br>1 W1 00000000 32个0<br>2 W2 00000000 32个0<br>3 W3 00000000 32个0<br>4 W4 00000000 32个0<br>5 W5 00000000 32个0<br>6 W6 00000000 32个0<br>7 W7 00000000 32个0<br>8 W8 00000000 32个0<br>9 W9 00000000 32个0<br>10 W10 00000000 32个0<br>11 W11 00000000 32个0<br>12 W12 00000000 32个0<br>13 W13 00000000 32个0<br>14 W14 00000000 长度值的前32位（全0）<br>15 W15 00000200 长度值的后32位（512 &#x3D; 0x200）</p><h4 id="B1的W16-到-W67和W’0-到-W’63用和B0一样的算法"><a href="#B1的W16-到-W67和W’0-到-W’63用和B0一样的算法" class="headerlink" title="B1的W16 到 W67和W’0 到 W’63用和B0一样的算法"></a>B1的W16 到 W67和W’0 到 W’63用和B0一样的算法</h4><p>得到的结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">W0-W67</span><br><span class="line">80000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000200</span><br><span class="line">80404000 00000000 01008080 10005000 00000000 002002a0 ac545c04 00000000</span><br><span class="line">09582a39 a0003000 00000000 00200280 a4515804 20200040 51609838 30005701</span><br><span class="line">a0002000 008200aa 6ad525d0 0a0e0216 b0f52042 fa7073b0 20000000 008200a8</span><br><span class="line">7a542590 22a20044 d5d6ebd2 82005771 8a202240 b42826aa eaf84e59 4898eaf9</span><br><span class="line">8207283d ee6775fa a3e0e0a0 8828488a 23b45a5d 628a22c4 8d6d0615 38300a7e</span><br><span class="line">e96260e5 2b60c020 502ed531 9e878cb9 218c38f8 dcae3cb7 2a3e0e0a e9e0c461</span><br><span class="line">8c3e3831 44aaa228 dc60a38b 518300f7</span><br><span class="line">W&#x27;1-W&#x27;63</span><br><span class="line">80000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">00000000 00000000 00000000 00000200 80404000 00000000 01008080 10005200</span><br><span class="line">80404000 002002a0 ad54dc84 10005000 09582a39 a02032a0 ac545c04 00200280</span><br><span class="line">ad09723d 80203040 51609838 30205581 04517804 20a200ea 3bb5bde8 3a0e5517</span><br><span class="line">10f50042 faf2731a 4ad525d0 0a8c02be caa105d2 d8d273f4 f5d6ebd2 828257d9</span><br><span class="line">f07407d0 968a26ee 3f2ea58b ca98bd88 08270a7d 5a4f5350 4918aef9 c0b0a273</span><br><span class="line">a1b37260 8ced573e 2e8de6b5 b01842f4 cad63ab8 49eae2e4 dd43d324 a6b786c7</span><br><span class="line">c8ee581d f7cefc97 7a10db3b 776748d8 adb200c9 98049e9f f65ead81 b863c496</span><br></pre></td></tr></table></figure><h2 id="压缩函数"><a href="#压缩函数" class="headerlink" title="压缩函数"></a>压缩函数</h2><p>V0 &#x3D;7380166f 4914b2b9 172442d7 da8a0600 a96f30bc 163138aa e38dee4d b0fb0e4e<br>计算压缩函数Vi+1 &#x3D; CF(V(i), B(i)) （0 ≤ i ≤ n−1，这里就B0、B1）<br>令A,B,C,D,E,F,G,H &#x3D; V0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FOR j=0 TO 63</span><br><span class="line">    SS1 ← ((A ≪ 12) + E + (Tj ≪ j)) ≪ 7</span><br><span class="line">    SS2 ← SS1 ⊕ (A ≪ 12)</span><br><span class="line">    T T1 ← F Fj (A, B, C) + D + SS2 + W′j</span><br><span class="line">    T T2 ← GGj (E, F, G) + H + SS1 + Wj</span><br><span class="line">    D ← C</span><br><span class="line">    C ← B ≪ 9</span><br><span class="line">    B ← A</span><br><span class="line">    A ← T T1</span><br><span class="line">    H ← G</span><br><span class="line">    G ← F ≪ 19</span><br><span class="line">    F ← E</span><br><span class="line">    E ← P0(T T2)</span><br><span class="line">ENDFOR</span><br><span class="line">V(i+1) ← ABCDEFGH ⊕ V(i)</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tj =</span><br><span class="line">79cc4519 (0 ≤ j ≤ 15)</span><br><span class="line">7a879d8a (16 ≤ j ≤ 63)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P0(X) = X ⊕ (X ≪ 9) ⊕ (X ≪ 17)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F Fj (X, Y, Z)= </span><br><span class="line">X ⊕ Y ⊕ Z (0 ≤ j ≤ 15)</span><br><span class="line">(X ∧ Y ) ∨ (X ∧ Z) ∨ (Y ∧ Z ) (16 ≤ j ≤ 63)</span><br><span class="line"></span><br><span class="line">GGj (X, Y, Z) = </span><br><span class="line">X ⊕ Y ⊕ Z (0 ≤ j ≤ 15)</span><br><span class="line">(X ∧ Y ) ∨ ( ¬X∧ Z) (16 ≤ j ≤ 63)</span><br></pre></td></tr></table></figure><p>先为B0来一轮压缩</p><p>得到V1 &#x3D; CF(ABCDEFGH)</p><p>再次让(ABCDEFGH) &#x3D; V1</p><p>得到V2 &#x3D; ABCDEFGH</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sm3案例&#39;abc&#39;</title>
      <link href="/sm3%E6%A1%88%E4%BE%8B-abc/"/>
      <url>/sm3%E6%A1%88%E4%BE%8B-abc/</url>
      
        <content type="html"><![CDATA[<p>参考官方文档<br><a href="https://oscca.gov.cn/sca/xxgk/2010-12/17/1002389/files/302a3ada057c4a73830536d03e683110.pdf">https://oscca.gov.cn/sca/xxgk/2010-12/17/1002389/files/302a3ada057c4a73830536d03e683110.pdf</a></p><h1 id="SM3加密过程"><a href="#SM3加密过程" class="headerlink" title="SM3加密过程"></a>SM3加密过程</h1><p>以abc为例子</p><p>字符串 “abc” 的ASCII码为：<br>a &#x3D; 0x61 &#x3D; 01100001<br>b &#x3D; 0x62 &#x3D; 01100010<br>c &#x3D; 0x63 &#x3D; 01100011<br>所以，”abc” 的二进制表示为：<br>01100001 01100010 01100011<br>24位</p><h2 id="消息填充"><a href="#消息填充" class="headerlink" title="消息填充"></a>消息填充</h2><ol><li><p><strong>添加比特1</strong><br> <strong>当前为：</strong>  01100001 01100010 01100011 1<br> <strong>当前位数：</strong> 25 位</p></li><li><p><strong>补 “0”</strong> 直到长度满足 (长度 % 512) &#x3D; 448<br> <strong>当前为：</strong>  01100001 01100010 01100011 1 0…0000(448-25 &#x3D; 423个0)<br> <strong>当前位数：</strong> 448位</p></li><li><p><strong>添加64位的长度信息</strong><br>abc共24位，用64位标识24即0000000000000018 H<br>00000000 00000000 00000000 00000000 00000000 00000000 00000000 00011000<br><strong>当前为：</strong> 01100001 01100010 01100011 1 0…000 0…000 00011000<br><strong>当前位数：</strong> 512位</p></li><li><p><strong>以512位一组分组</strong><br>因为这里只有512位，所以一组即可B0</p></li></ol><h2 id="消息扩展"><a href="#消息扩展" class="headerlink" title="消息扩展"></a>消息扩展</h2><p>扩展为（W0, W1, …, W67 和 W‘0, W’1, …, W‘63）<br>一个W占32位，共132个W</p><h3 id="前16个W（W0-15）就是填充完的消息"><a href="#前16个W（W0-15）就是填充完的消息" class="headerlink" title="前16个W（W0-15）就是填充完的消息"></a>前16个W（W0-15）就是填充完的消息</h3><p>jWj十六进制说明<br>0W061626380“abc” + 1个比特1<br>1W100000000补零<br>2W200000000补零<br>3W300000000补零<br>4W400000000补零<br>5W500000000补零<br>6W600000000补零<br>7W700000000补零<br>8W800000000补零<br>9W900000000补零<br>10W1000000000补零<br>11W1100000000补零<br>12W1200000000补零<br>13W1300000000补零<br>14W1400000000补零<br>15W1500000018原始长度24比特</p><h3 id="扩展生成-W16-到-W67"><a href="#扩展生成-W16-到-W67" class="headerlink" title="扩展生成 W16 到 W67"></a>扩展生成 W16 到 W67</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOR j=16 TO 67 </span><br><span class="line">    Wj ←P1(Wj−16 ⊕Wj−9 ⊕(Wj−3 ≪15))⊕(Wj−13 ≪ 7)⊕Wj−6 </span><br><span class="line">ENDFOR</span><br></pre></td></tr></table></figure><p>其中P1具体实现为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P1(X) = X ⊕ (X ≪ 15) ⊕ (X ≪ 23)</span><br></pre></td></tr></table></figure><h3 id="扩展生成-W’0-到-W’63"><a href="#扩展生成-W’0-到-W’63" class="headerlink" title="扩展生成 W’0 到 W’63"></a>扩展生成 W’0 到 W’63</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOR j=0 TO 63</span><br><span class="line">    W′j = Wj ⊕Wj+4     //Wi与Wi+4互相异或</span><br><span class="line">ENDFOR</span><br></pre></td></tr></table></figure><p>此时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">W0W1...W67</span><br><span class="line">61626380 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000018</span><br><span class="line">9092e200 00000000 000c0606 719c70ed 00000000 8001801f 939f7da9 00000000</span><br><span class="line">2c6fa1f9 adaaef14 00000000 0001801e 9a965f89 49710048 23ce86a1 b2d12f1b</span><br><span class="line">e1dae338 f8061807 055d68be 86cfd481 1f447d83 d9023dbf 185898e0 e0061807</span><br><span class="line">050df55c cde0104c a5b9c955 a7df0184 6e46cd08 e3babdf8 70caa422 0353af50</span><br><span class="line">a92dbca1 5f33cfd2 e16f6e89 f70fe941 ca5462dc 85a90152 76af6296 c922bdb2</span><br><span class="line">68378cf5 97585344 09008723 86faee74 2ab908b0 4a64bc50 864e6e08 f07e6590</span><br><span class="line">325c8f78 accb8011 e11db9dd b99c0545</span><br><span class="line"></span><br><span class="line">W′0W′1...W′63</span><br><span class="line">61626380 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">00000000 00000000 00000000 00000018 9092e200 00000000 000c0606 719c70f5</span><br><span class="line">9092e200 8001801f 93937baf 719c70ed 2c6fa1f9 2dab6f0b 939f7da9 0001801e</span><br><span class="line">b6f9fe70 e4dbef5c 23ce86a1 b2d0af05 7b4cbcb1 b177184f 2693ee1f 341efb9a</span><br><span class="line">fe9e9ebb 210425b8 1d05f05e 66c9cc86 1a4988df 14e22df3 bde151b5 47d91983</span><br><span class="line">6b4b3854 2e5aadb4 d5736d77 a48caed4 c76b71a9 bc89722a 91a5caab f45c4611</span><br><span class="line">6379de7d da9ace80 97c00c1f 3e2d54f3 a263ee29 12f15216 7fafe5b5 4fd853c6</span><br><span class="line">428e8445 dd3cef14 8f4ee92b 76848be4 18e587c8 e6af3c41 6753d7d5 49e260d5</span><br></pre></td></tr></table></figure><h2 id="压缩函数"><a href="#压缩函数" class="headerlink" title="压缩函数"></a>压缩函数</h2><p>IV &#x3D;7380166f 4914b2b9 172442d7 da8a0600 a96f30bc 163138aa e38dee4d b0fb0e4e</p><p>令A,B,C,D,E,F,G,H &#x3D; IV</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FOR j=0 TO 63</span><br><span class="line">    SS1 ← ((A ≪ 12) + E + (Tj ≪ j)) ≪ 7</span><br><span class="line">    SS2 ← SS1 ⊕ (A ≪ 12)</span><br><span class="line">    TT1 ← FFj (A, B, C) + D + SS2 + W′j</span><br><span class="line">    TT2 ← GGj (E, F, G) + H + SS1 + Wj</span><br><span class="line">    D ← C</span><br><span class="line">    C ← B ≪ 9</span><br><span class="line">    B ← A</span><br><span class="line">    A ← TT1</span><br><span class="line">    H ← G</span><br><span class="line">    G ← F ≪ 19</span><br><span class="line">    F ← E</span><br><span class="line">    E ← P0(TT2)</span><br><span class="line">ENDFOR</span><br><span class="line">V(i+1) ← ABCDEFGH ⊕ V(i)</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tj =</span><br><span class="line">79cc4519 (0 ≤ j ≤ 15)</span><br><span class="line">7a879d8a (16 ≤ j ≤ 63)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P0(X) = X ⊕ (X ≪ 9) ⊕ (X ≪ 17)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FFj (X, Y, Z)= </span><br><span class="line">X ⊕ Y ⊕ Z (0 ≤ j ≤ 15)</span><br><span class="line">(X ∧ Y ) ∨ (X ∧ Z) ∨ (Y ∧ Z ) (16 ≤ j ≤ 63)</span><br><span class="line"></span><br><span class="line">GGj (X, Y, Z) = </span><br><span class="line">X ⊕ Y ⊕ Z (0 ≤ j ≤ 15)</span><br><span class="line">(X ∧ Y ) ∨ ( ¬X∧ Z) (16 ≤ j ≤ 63)</span><br></pre></td></tr></table></figure><h3 id="最后结果"><a href="#最后结果" class="headerlink" title="最后结果"></a>最后结果</h3><p>经过压缩函数得到新的ABCDEFGH<br>A &#x3D; 66c7f0f4<br>B &#x3D; 62eeedd9<br>C &#x3D; d1f2d46b<br>D &#x3D; dc10e4e2<br>E &#x3D; 4167c487<br>F &#x3D; 5cf2f7a2<br>G &#x3D; 297da02b<br>H &#x3D; 8f4ba8e0</p><p>即结果为 66c7f0f4 62eeedd9 d1f2d46b dc10e4e2 4167c487 5cf2f7a2 297da02b 8f4ba8e0</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IK重定向</title>
      <link href="/IK%E9%87%8D%E5%AE%9A%E5%90%91/"/>
      <url>/IK%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p>模之屋：<a href="https://www.aplaybox.com/">https://www.aplaybox.com/</a><br>blender2.93：插件cats只支持到2.93<br>UE5.2用于重定向动作，5.4有bug<br>UE5.4用于自动贴合IK<br>blender插件CATS：<a href="https://github.com/absolute-quantum/cats-blender-plugin%E5%AF%BC%E5%85%A5pmx%E6%A8%A1%E5%9E%8B">https://github.com/absolute-quantum/cats-blender-plugin导入pmx模型</a></p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>blender模型单位与UE不同，直接导入UE会导致模型巨大<a href="https://blog.csdn.net/ONE_SIX_MIX/article/details/119879752">https://blog.csdn.net/ONE_SIX_MIX/article/details/119879752</a> 根据这个来</p><p><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E6%94%B9%E5%A4%A7%E5%B0%8F.png" alt="改大小"><br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E6%94%B9%E5%A4%A7%E5%B0%8F(2).png" alt="改大小"><br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E6%94%B9%E5%A4%A7%E5%B0%8F(3).png" alt="改大小"><br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E6%94%B9%E5%A4%A7%E5%B0%8F(4).png" alt="改大小"></p><h2 id="blender内操作"><a href="#blender内操作" class="headerlink" title="blender内操作"></a>blender内操作</h2><ol><li>模型下好后使用cats导入blender，把blender内带的东西全删了</li><li>FixModel工具修复模型，修复一次可能不够，在姿态模式下移动骨骼看是否有bug，一般两次即可<br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E5%8D%95%E5%87%BBfixmodel.png" alt="单击fixmodel"><br><em>仅修复一次可能产生bug</em><br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E4%BB%85%E4%BF%AE%E5%A4%8D%E4%B8%80%E6%AC%A1%E6%A1%88%E4%BE%8B.png" alt="仅修复一次案例"><br>不要随意缩放模型，感觉身高不对要在导入时改好，导入后改会出bug，一个box默认2M</li><li>选择骨骼进入编辑模式 添加-&gt;单段骨骼(shift+A)将新增的骨骼Bone重命名为Root<br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E5%BB%BA%E7%AB%8Broot%E9%AA%A8%E9%AA%BC.png" alt="alt text"></li><li>点击Hips骨骼组 骨骼属性-&gt;关系-&gt;父级 选择Root作为Hips的父级，这样符合规范<img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E6%8C%87%E5%AE%9A%E7%88%B6%E7%BA%A7.png" alt="指定父级"></li><li>将Root的父级重命名与Root的父级的父级一样<img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E9%87%8D%E5%91%BD%E5%90%8D%E7%88%B6%E7%BA%A7.png" alt="重命名父级"></li><li>导出为FBX文件<br>导出选择<br>包括-&gt;限制-&gt;选定的物体、活动集合<br>几何数据-&gt;平滑-&gt;面<br>骨架-&gt;取消勾选添加叶骨<br>取消勾选烘焙动画（无动画）</li></ol><h2 id="UE-5-2-内操作"><a href="#UE-5-2-内操作" class="headerlink" title="UE(5.2)内操作"></a>UE(5.2)内操作</h2><p>这里使用虚幻争霸的aurora动作<br>为要导入的角色创建一个文件夹</p><p>IK绑定</p><ol><li>导入FBX文件，直接点导入所有即可</li><li>动画-&gt;IK绑定-&gt;IK绑定 绑定指定骨骼网格体<br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E7%BB%91%E5%AE%9A%E6%8C%87%E5%AE%9A%E9%AA%A8%E9%AA%BC%E7%BD%91%E6%A0%BC%E4%BD%93.png" alt="绑定指定骨骼网格体"></li><li>将Hips骨骼绑定为重定向根，不是Root！Hips（骨盆）是身体运动的物理中心，而Root是代指角色整体<br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/Hips%E9%AA%A8%E9%AA%BC%E7%BB%91%E5%AE%9A%E4%B8%BA%E9%87%8D%E5%AE%9A%E5%90%91%E6%A0%B9.png" alt="Hips骨骼绑定为重定向根"><br>如果这一步发现骨骼的父级有问题比如左手衣袖跟着右手动，可使用skeletal mesh editing tools插件更改骨骼父级<br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/skeletal%20mesh%20editing%20tools%E6%8F%92%E4%BB%B6.png"></li><li>设置重定向链，规则：<ul><li>重定向链的骨骼要是连续向下降级的，不能有同级骨骼</li><li>要有与复制动作的重定向对象相同数量、名字的重定向链</li><li>一定起码要有Spine、LeftArm、RightArm、LeftLeg、RightLeg五个重定向链，root自己也可以算一个重定向链<br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E9%87%8D%E5%AE%9A%E5%90%91%E9%93%BE.png"></li></ul></li><li>新增解算器-&gt;全体IK，将根骨骼（Root）设置为“在选定解算器上设置根骨骼”<br>重定向根骨骼(Hips)选择“将设置添加到选定骨骼”<br>四肢除终点之外的骨骼设置为“将设置添加到选定骨骼”<br>而终点设置“新IK目标”，此时系统会自动绑定所属手臂的IK目标<br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E7%BB%91%E5%AE%9AIK%E7%9B%AE%E6%A0%87.png"><br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E7%BB%91%E5%AE%9A%E5%90%8E%E6%95%88%E6%9E%9C%E5%9B%BE.png"><br>指定角色IK绑定完成，接下来重复上面做法为重定向源也绑定骨骼</li></ol><h2 id="IK重定向"><a href="#IK重定向" class="headerlink" title="IK重定向"></a>IK重定向</h2><ol><li>动画-&gt;IK绑定-&gt;IK重定向器，指定源IK与指定角色IK</li><li>调整PreviewSettings-&gt;目标网格体缩放，缩放至和源IK重叠</li><li>使用UE5.4版本打开当前当前项目，只有5.4及其以上版本可以自动对齐IK<br>以下骨骼用普通对齐：<ul><li>胳膊及其子骨骼</li><li>大腿及其子骨骼</li><li>脊椎骨骼</li><li>颈部骨骼</li><li>头部骨骼</li><li>十根手指骨骼使用网格对齐<br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E6%89%8B%E6%8C%87%E5%AF%B9%E9%BD%90.png"></li></ul></li><li>绑定骨骼后 创建-&gt;导出姿势资产</li><li>进入导出的姿势资产，将默认姿势的权重拉到1</li><li>创建资产-&gt;创建动画-&gt;当前姿势 创建好动画序列<br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E5%88%9B%E5%BB%BA%E5%A5%BD%E7%9A%84%E5%8A%A8%E7%94%BB%E5%BA%8F%E5%88%97.png"><br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E4%BD%BF%E7%94%A8%E5%BD%93%E5%89%8D%E5%A7%BF%E5%8A%BF%E5%AF%BC%E5%87%BA.png"></li><li>右击创建好的动画序列 资产操作-&gt;导出 将动画导出为FBX文件，关闭5.4</li><li>重新打开5.2，将刚刚创建的FBX动画文件导入5.2，由于此动画文件没有绑定骨骼，需要自行绑定一个，绑定指定角色骨骼就好</li><li>进入IK重定向器 创建-&gt;从动画序列导入 这样就实现用5.4的自动对齐实现了给5.2对齐<br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E5%AF%BC%E5%85%A5%E5%8A%A8%E7%94%BBIK.png"></li><li>找到重定向目标的动作蓝图 重定向动画资产-&gt;复制并重定向动画资产&#x2F;蓝图，选择刚刚绑定好的重定向器，这样基于其他角色动作的动作蓝图就做好了<br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E9%87%8D%E5%AE%9A%E5%90%91%E5%8A%A8%E7%94%BB%E8%B5%84%E4%BA%A7.png"><br>可能会出现没有完全导出所有动作的情况，此时要回到重定向器中，从资产浏览器中导出所有动作<br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E4%BB%8E%E9%87%8D%E5%AE%9A%E5%90%91%E5%99%A8%E4%B8%AD%E5%AF%BC%E5%87%BA%E6%89%80%E6%9C%89%E5%8A%A8%E4%BD%9C.png"><br>   最好分批导出，有卡死的可能</li><li>直接将源角色蓝图的骨骼网格体和动画蓝图改为指定角色的网格体动画蓝图，再将默认pawn类设置为该动画蓝图即可<br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E5%B0%86%E6%BA%90%E8%A7%92%E8%89%B2%E8%93%9D%E5%9B%BE%E7%9A%84%E9%AA%A8%E9%AA%BC%E7%BD%91%E6%A0%BC%E4%BD%93%E5%92%8C%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE%E6%94%B9%E4%B8%BA%E6%8C%87%E5%AE%9A%E8%A7%92%E8%89%B2%E7%9A%84%E7%BD%91%E6%A0%BC%E4%BD%93%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE.png"><br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E5%B0%86%E6%BA%90%E8%A7%92%E8%89%B2%E8%93%9D%E5%9B%BE%E7%9A%84%E9%AA%A8%E9%AA%BC%E7%BD%91%E6%A0%BC%E4%BD%93%E5%92%8C%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE%E6%94%B9%E4%B8%BA%E6%8C%87%E5%AE%9A%E8%A7%92%E8%89%B2%E7%9A%84%E7%BD%91%E6%A0%BC%E4%BD%93%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE2.png"><br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E5%B0%86%E6%BA%90%E8%A7%92%E8%89%B2%E8%93%9D%E5%9B%BE%E7%9A%84%E9%AA%A8%E9%AA%BC%E7%BD%91%E6%A0%BC%E4%BD%93%E5%92%8C%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE%E6%94%B9%E4%B8%BA%E6%8C%87%E5%AE%9A%E8%A7%92%E8%89%B2%E7%9A%84%E7%BD%91%E6%A0%BC%E4%BD%93%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE3.png"><br>名字是aurora实际上已经改为指定骨骼网格体<br><img src="/IK%E9%87%8D%E5%AE%9A%E5%90%91/%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C.png"></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2026-1-16-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2026-1-16-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker使用教程</title>
      <link href="/docker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/docker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="docker就是用来把某人的程序完好运行在另一个人电脑上的小虚拟机"><a href="#docker就是用来把某人的程序完好运行在另一个人电脑上的小虚拟机" class="headerlink" title="docker就是用来把某人的程序完好运行在另一个人电脑上的小虚拟机"></a>docker就是用来把某人的程序完好运行在另一个人电脑上的小虚拟机</h1><blockquote><p>YSir<br>2025.10.28<br>以下内容只涉及Windows+WSL</p></blockquote><p>参考：<a href="https://github.com/tech-shrimp/docker_installer.git">https://github.com/tech-shrimp/docker_installer.git</a></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ol><li>打开<code>virtual machine platform</code>和<code>适用于Linux的Windows子系统</code>两个功能</li><li>运行俩命令 <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl --<span class="built_in">set</span>-default-version <span class="number">2</span>     //要求默认版本为wsl2</span><br><span class="line">wsl --update --web-download     //安装wsl</span><br></pre></td></tr></table></figure></li><li>下docker desktop <a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a></li></ol><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ol><li><p><code>docker pull [&lt;仓库地址&gt;docker.io]/[&lt;命名空间(作者名)&gt;library]/niginx:[&lt;版本号&gt;latest]</code>，如果全部简化则为官方镜像<code>docker pull niginx</code>，一个镜像库由<code>仓库地址+命名空间+镜像名</code>组成</p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">YSir</span>&gt;<span class="title">docker</span> <span class="title">pull</span> <span class="title">nginx</span>         //<span class="title">linux</span>系统需要加<span class="title">sudo</span></span></span><br><span class="line"><span class="function"><span class="title">Using</span> <span class="title">default</span> <span class="title">tag</span>: <span class="title">latest</span></span></span><br><span class="line"><span class="function"><span class="title">latest</span>: <span class="title">Pulling</span> <span class="title">from</span> <span class="title">library</span>/<span class="title">nginx</span></span></span><br><span class="line"><span class="function">38513<span class="title">bd72563</span>: <span class="title">Pull</span> <span class="title">complete</span></span></span><br><span class="line"><span class="function"><span class="title">a0a6ab141558</span>: <span class="title">Pull</span> <span class="title">complete</span></span></span><br><span class="line"><span class="function">0<span class="title">e86847a3920</span>: <span class="title">Pull</span> <span class="title">complete</span></span></span><br><span class="line"><span class="function">1<span class="title">bace2083289</span>: <span class="title">Pull</span> <span class="title">complete</span></span></span><br><span class="line"><span class="function">89<span class="title">df300a082a</span>: <span class="title">Pull</span> <span class="title">complete</span></span></span><br><span class="line"><span class="function">35<span class="title">fb9ffa6621</span>: <span class="title">Pull</span> <span class="title">complete</span></span></span><br><span class="line"><span class="function">5545<span class="title">b08f9d26</span>: <span class="title">Pull</span> <span class="title">complete</span></span></span><br><span class="line"><span class="function"><span class="title">Digest</span>: <span class="title">sha256:f547e3d0d5d02f7009737b284abc87d808e4252b42dceea361811e9fc606287f</span></span></span><br><span class="line"><span class="function"><span class="title">Status</span>: <span class="title">Downloaded</span> <span class="title">newer</span> <span class="title">image</span> <span class="title">for</span> <span class="title">nginx:latest</span></span></span><br><span class="line"><span class="function"><span class="title">docker.io</span>/<span class="title">library</span>/<span class="title">nginx:latest</span></span></span><br></pre></td></tr></table></figure></li><li><p>配置镜像站（下载有问题）,复制：</p> <figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;https://docker.m.daocloud.io&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.1panel.live&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://hub.rat.dev&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 粘贴到此处：<img src="/docker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE.png">点击apply&amp;restart</p></li><li><p><code>docker images</code>查看已下载的镜像</p></li><li><p><code>docker rmi &lt;镜像名或ID&gt;</code>删除已下载的镜像(i代表images),<code>docker rm</code>即删除正在运行的容器，加<code>-f</code>可强制删除</p></li><li><p><code>docker run &lt;镜像名&gt; [-d] [-p &lt;本机端口&gt;:&lt;容器端口&gt;] [-v &lt;本机目录:容器目录&gt;]</code><strong>运行容器</strong>，</p><ol><li><code>-d</code>可以防止刷屏，容器放后台(实际上如果不pull直接run也可以,docker将自动pull)</li><li><code>-p</code>端口映射，将容器与本机互通<br>  例如  <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">YSir</span>&gt;<span class="title">docker</span> <span class="title">run</span> -<span class="title">p</span> 80:80 <span class="title">nginx</span></span></span><br><span class="line"><span class="function">/<span class="title">docker</span>-<span class="title">entrypoint.sh</span>: /<span class="title">docker</span>-<span class="title">entrypoint.d</span>/ <span class="title">is</span> <span class="title">not</span> <span class="title">empty</span>, <span class="title">will</span> <span class="title">attempt</span> <span class="title">to</span> <span class="title">perform</span> <span class="title">configuration</span></span></span><br><span class="line"><span class="function">/<span class="title">docker</span>-<span class="title">entrypoint.sh</span>: <span class="title">Looking</span> <span class="title">for</span> <span class="title">shell</span> <span class="title">scripts</span> <span class="title">in</span> /<span class="title">docker</span>-<span class="title">entrypoint.d</span>/</span></span><br><span class="line"><span class="function">/<span class="title">docker</span>-<span class="title">entrypoint.sh</span>: <span class="title">Launching</span> /<span class="title">docker</span>-<span class="title">entrypoint.d</span>/10-<span class="title">listen</span>-<span class="title">on</span>-<span class="title">ipv6</span>-<span class="title">by</span>-<span class="title">default.sh</span></span></span><br><span class="line"><span class="function">10-<span class="title">listen</span>-<span class="title">on</span>-<span class="title">ipv6</span>-<span class="title">by</span>-<span class="title">default.sh</span>: <span class="title">info</span>: <span class="title">Getting</span> <span class="title">the</span> <span class="title">checksum</span> <span class="title">of</span> /<span class="title">etc</span>/<span class="title">nginx</span>/<span class="title">conf.d</span>/<span class="title">default.conf</span></span></span><br><span class="line"><span class="function">10-<span class="title">listen</span>-<span class="title">on</span>-<span class="title">ipv6</span>-<span class="title">by</span>-<span class="title">default.sh</span>: <span class="title">info</span>: <span class="title">Enabled</span> <span class="title">listen</span> <span class="title">on</span> <span class="title">IPv6</span> <span class="title">in</span> /<span class="title">etc</span>/<span class="title">nginx</span>/<span class="title">conf.d</span>/<span class="title">default.conf</span></span></span><br><span class="line"><span class="function">/<span class="title">docker</span>-<span class="title">entrypoint.sh</span>: <span class="title">Sourcing</span> /<span class="title">docker</span>-<span class="title">entrypoint.d</span>/15-<span class="title">local</span>-<span class="title">resolvers.envsh</span></span></span><br><span class="line"><span class="function">/<span class="title">docker</span>-<span class="title">entrypoint.sh</span>: <span class="title">Launching</span> /<span class="title">docker</span>-<span class="title">entrypoint.d</span>/20-<span class="title">envsubst</span>-<span class="title">on</span>-<span class="title">templates.sh</span></span></span><br><span class="line"><span class="function">/<span class="title">docker</span>-<span class="title">entrypoint.sh</span>: <span class="title">Launching</span> /<span class="title">docker</span>-<span class="title">entrypoint.d</span>/30-<span class="title">tune</span>-<span class="title">worker</span>-<span class="title">processes.sh</span></span></span><br><span class="line"><span class="function">/<span class="title">docker</span>-<span class="title">entrypoint.sh</span>: <span class="title">Configuration</span> <span class="title">complete</span>; <span class="title">ready</span> <span class="title">for</span> <span class="title">start</span> <span class="title">up</span></span></span><br><span class="line"><span class="function">2025/10/31 13:45:04 [<span class="title">notice</span>] 1#1: <span class="title">using</span> <span class="title">the</span> &quot;<span class="title">epoll</span>&quot; <span class="title">event</span> <span class="title">method</span></span></span><br><span class="line"><span class="function">2025/10/31 13:45:04 [<span class="title">notice</span>] 1#1: <span class="title">nginx</span>/1.29.3</span></span><br><span class="line"><span class="function">2025/10/31 13:45:04 [<span class="title">notice</span>] 1#1: <span class="title">built</span> <span class="title">by</span> <span class="title">gcc</span> 14.2.0 (<span class="title">Debian</span> 14.2.0-19)</span></span><br><span class="line"><span class="function">2025/10/31 13:45:04 [<span class="title">notice</span>] 1#1: <span class="title">OS</span>: <span class="title">Linux</span> 5.15.167.4-<span class="title">microsoft</span>-<span class="title">standard</span>-<span class="title">WSL2</span></span></span><br><span class="line"><span class="function">2025/10/31 13:45:04 [<span class="title">notice</span>] 1#1: <span class="title">getrlimit</span>(<span class="title">RLIMIT_NOFILE</span>): 1048576:1048576</span></span><br><span class="line"><span class="function">2025/10/31 13:45:04 [<span class="title">notice</span>] 1#1: <span class="title">start</span> <span class="title">worker</span> <span class="title">processes</span></span></span><br><span class="line"><span class="function">2025/10/31 13:45:04 [<span class="title">notice</span>] 1#1: <span class="title">start</span> <span class="title">worker</span> <span class="title">process</span> 29</span></span><br><span class="line"><span class="function">2025/10/31 13:45:04 [<span class="title">notice</span>] 1#1: <span class="title">start</span> <span class="title">worker</span> <span class="title">process</span> 30</span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure>  此时我访问<code>localhost:80</code>就会出现nginx的欢迎界面，ctrl+c以结束</li><li><code>-v</code>设置挂载卷，设置后使得容器文件夹使用本机文件夹，但只能访问本机文件夹(<strong>注:有一个历史遗留问题，Linux目录路径为<code>/</code>而Windows为<code>\</code></strong>)<br> 例子 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\YSir&gt;docker run -p 80:80 -v C:\website\html:/usr/share/nginx/html nginx</span><br><span class="line">//一定要在C:\website\html中也创建一个index.html，否则403</span><br></pre></td></tr></table></figure> 还可以使用<strong>命名卷挂载</strong><ul><li>创建挂载卷<code>docker volume create &lt;挂载卷名&gt;</code></li><li>查看挂载卷位置<code>docker volume inspect &lt;挂载卷名&gt;</code></li><li>命名卷会自动复制第一次使用时会自动拷贝容器内对应文件</li><li><code>docker volume list</code>可例出所有使用中的命名卷</li><li><code>docker volume rm &lt;命名卷名&gt;</code>删除命名卷</li><li><code>docekr volume prune -a</code>删除所有未在使用的命名卷</li><li>这玩意在Windows里有小bug，先不管</li></ul></li><li><code>-e</code>设置环境变量<br> 如 <figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -d \</span></span><br><span class="line"><span class="language-bash">-p 27017:27017 \</span></span><br><span class="line"><span class="language-bash">-e MONGO_INITDB_ROOT_USERNAME = tech \</span></span><br><span class="line"><span class="language-bash">-e MONGO_INITDB_ROOT_PASSWORD = shrimp \</span></span><br><span class="line"><span class="language-bash">mongo</span></span><br></pre></td></tr></table></figure> 这样数据库的账号密码就会作为环境变量传递进去，使mongo数据库预设好账号密码。<br> 使用<code>mongosh &quot;mongodb://tech:shrimp@111.231.100.92:27017&quot;</code>即可连入数据库(111.231.100.92是别人的服务器)，不清楚环境变量可以在镜像文档里找</li><li><code>--name &lt;容器名&gt;</code>为容器自定义名称以取代容器ID，这样就可以直接用<code>docker rm &lt;容器名&gt;</code>来删除容器</li><li><code>-t</code>可进入容器，常搭配<code>--rm</code>使用</li><li><code>--rm</code>当容器停止运行时删除容器<br> 例<code>docker run -t --rm alpine</code>(alpine是一个轻型linux)，这样可以直接进入容器内部，并在退出容器的同时删除容器，用于临时调试容器与之相同的还有<code>--restart</code><br> 例<code>docker run --restart always nginx</code>如果容器被关闭就会立即重启<br> 例<code>docker run --restart unless-stopped</code>如果是非手动停止容器就立即重启</li><li><code>start</code>启动容器</li><li><code>stop</code>停止容器，使用start和stop可以让docker将容器数据保留下来，避免被删除</li></ol></li><li><p><code>docker ps</code>查看正在运行的容器(镜像可比作类，而容器就是对象)<code>-a</code>可查看所有容器</p></li><li><p><code>docker stop &lt;容器ID&gt;</code>停止某运行中的容器，以方便删除容器</p></li><li><p><code>docker container prune</code>可以直接删掉停止使用的容器</p></li><li><p><code>docker inspect &lt;容器ID&gt;</code>查看容器详细信息，可查看启动参数，内容可能看不懂，丢给ai就好</p></li><li><p><code>docker create &lt;镜像名&gt;</code>与<code>run</code>差不多，唯一区别就是需要手动start</p></li><li><p><code>docker log &lt;容器ID&gt;</code>查看容器日志<code>-f</code>可实时刷新</p></li></ol><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p><code>docker</code>用<code>linux</code>的<code>cgroups</code>和<code>namespaces</code>实现容器化，<code>cgroups</code>用来限制容器资源调度上限，<code>namespaces</code>用来隔离容器使容器看不见外部情况</p><ol><li><code>docker exec &lt;容器ID&gt; &lt;linux命令&gt;</code>在容器内部执行Linux命令，如<code>docker exec d123d123 ps -ef</code>查看容器d123d123的进程，还有常用命令<code>docker exec -it &lt;容器ID&gt; /bin/sh</code>进入一个容器内部获得其shell，当然容器简单到连文本编辑工具vi都没有，要自己安装</li><li>进入容器内部后使用<code>cat /etc/os-release</code>可查看容器所使用的linux系统，依照系统下载文本编辑器等工具，以nginx举例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it &lt;容器ID&gt; /bin/sh        //进入容器</span><br><span class="line"># cat /etc/os-release</span><br><span class="line">PRETTY_NAME=&quot;Debian GNU/Linux 13 (trixie)&quot;      //这里可发现使用的是Debian</span><br><span class="line">...</span><br><span class="line"># apt update        //debain使用apt命令安装软件，更新apt索引</span><br><span class="line"># apt install vim       //安装文本编辑器vim</span><br><span class="line"># cd /usr/share/nginx/html      //进入网页默认文件夹</span><br><span class="line"># cat index.html        //编辑默认网页</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="制作镜像并推送到dockerhub"><a href="#制作镜像并推送到dockerhub" class="headerlink" title="制作镜像并推送到dockerhub"></a>制作镜像并推送到dockerhub</h2><p>感觉对我没啥用，下次再说 :)</p><h2 id="Docker网络设置"><a href="#Docker网络设置" class="headerlink" title="Docker网络设置"></a>Docker网络设置</h2><h3 id="bridge桥接模式"><a href="#bridge桥接模式" class="headerlink" title="bridge桥接模式"></a>bridge桥接模式</h3><p>默认birdge桥接模式，所有容器默认连接到容器内网，所有容器分配一个IP地址(大多172.17.x.x)，并且容器内网与本机网络隔离，<br><code>docker network create network1</code>可创建子网，仍属于桥接模式，可指定容器加入子网，不同子网的容器不可相互通信，同一子网的好处是可以直接使用容器名访问而非IP<br>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//该容器没进行端口映射，目的是不能让客户机直接访问数据库</span><br><span class="line">root@LAPTOP-L57F2HR5:/# docker run -d \</span><br><span class="line">&gt; --name my_mongodb \           //为容器命名，使得同一子网的容器可以直接找到该容器不需要知道IP</span><br><span class="line">&gt; -e MONGO_INITDB_ROOT_USERNAME=tech \      //设置环境变量</span><br><span class="line">&gt; -e MONGO_INITDB_ROOT_PASSWORD=shrimp \</span><br><span class="line">&gt; --network network1 \      //接入子网network1</span><br><span class="line">&gt; mongo</span><br><span class="line">0787c32666073e64489e84d67fcec037ebd70de00c514a3aa1d17b41e6f08555</span><br><span class="line"></span><br><span class="line">//启动了一个mongodb的客户端，这才是希望客户机看到的，所以设置了端口映射</span><br><span class="line">root@LAPTOP-L57F2HR5:/# docker run -d \</span><br><span class="line">&gt; --name my_mongodb_express \</span><br><span class="line">&gt; -p 8081:8081 \</span><br><span class="line">//这里并没有写my_mongodb的IP而是直接告诉他名字，因为容器子网内部有一个DNS</span><br><span class="line">&gt; -e ME_CONFIG_MONGODB_SERVER=my_mongodb \</span><br><span class="line">&gt; -e ME_CONFIG_MONGODB_ADMINUSERNAME=tech \</span><br><span class="line">&gt; -e ME_CONFIG_MONGODB_ADMINPASSWORD=shrimp \</span><br><span class="line">&gt; --network network1 \</span><br><span class="line">&gt; mongo-express</span><br></pre></td></tr></table></figure><p>这样一来就可以在浏览器里访问该数据库了<br><img src="/docker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/%E9%BB%98%E8%AE%A4%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.png">默认用户名为admin，密码为pass<br><img src="/docker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2.png"><br>接下来进入mongodb-express里看看是怎么个事</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@LAPTOP-L57F2HR5:/# docker exec -it my_mongodb_express /bin/sh</span><br><span class="line">/app # ping my_mongodb      //这里ping的是容器名</span><br><span class="line">PING my_mongodb (172.18.0.2): 56 data bytes     //而这里自动转为IP地址，所以容器子网里有DNS</span><br><span class="line">64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.153 ms</span><br><span class="line">64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.148 ms</span><br><span class="line">64 bytes from 172.18.0.2: seq=2 ttl=64 time=0.095 ms</span><br></pre></td></tr></table></figure><p>子网逻辑图<br><img src="/docker%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/%E5%AD%90%E7%BD%91%E9%80%BB%E8%BE%91%E5%9B%BE.png"></p><h3 id="Host模式"><a href="#Host模式" class="headerlink" title="Host模式"></a>Host模式</h3><p>该模式容器直接共享本机网络，使用本机IP，无需<code>-p</code>进行端口映射<br><code>docker run --network host &lt;容器名&gt;</code>以设置Host模式<br>例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@LAPTOP-L57F2HR5:/# docker run -d --network host nginx      //此时直接访问localhost:80可访问</span><br><span class="line">root@LAPTOP-L57F2HR5:/# docker exec -it 777a5aed9007 /bin/sh        //进入容器看看IP</span><br><span class="line"># apt update</span><br><span class="line"># apt install iproute2          //想查看IP先安装这个工具</span><br><span class="line"># ip addr show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host proto kernel_lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether b6:6a:6d:f5:3d:09 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0     //看这里的IP，有bug:(，先不管，反正应该相同就对了:)</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><h3 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h3><p><code>docker network list</code>列出已有网络(包括已创建子网)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID     NAME       DRIVER    SCOPE</span><br><span class="line">b4d69f5d9f25   bridge     bridge    local       //系统自带</span><br><span class="line">5f5d36bcccdd   host       host      local       //系统自带</span><br><span class="line">af2dd9a83849   network1   bridge    local</span><br><span class="line">ca033ed54219   none       null      local       //系统自带</span><br></pre></td></tr></table></figure><p><code>docker network rm &lt;网络名&gt;</code>删除已有网络(系统自带无法删除)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git使用教程</title>
      <link href="/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="git就是用来后悔和溯源的备份仓库"><a href="#git就是用来后悔和溯源的备份仓库" class="headerlink" title="git就是用来后悔和溯源的备份仓库"></a>git就是用来后悔和溯源的备份仓库</h1><h2 id="配置外部仓库账号"><a href="#配置外部仓库账号" class="headerlink" title="配置外部仓库账号"></a>配置外部仓库账号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;John Doe&quot;</span><br><span class="line">$ git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure><p>最好更改一下代理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:7897</span><br><span class="line">git config --global https.proxy https://127.0.0.1:7897</span><br></pre></td></tr></table></figure><h2 id="创建本地git仓库"><a href="#创建本地git仓库" class="headerlink" title="创建本地git仓库"></a>创建本地git仓库</h2><p>方法1.<br>克隆别人的仓库<code>git clone &lt;address&gt;</code></p><p>方法2. </p><ol><li>在文件夹中执行<code>git init</code>以创建.git文件夹，即代码仓库</li><li><code>git add &lt;需要入库的文件&gt;</code>把文件放入暂存区(<code>git add .</code>可以把文件夹的所有文件放入暂存区)</li><li><code>git commit [-m &quot;要备注的字符串&quot;]</code>提交暂存区的文件</li></ol><p>此时仅仅只是导入本地仓库，还没进入GitHub</p><h2 id="连接绑定远程仓库"><a href="#连接绑定远程仓库" class="headerlink" title="连接绑定远程仓库"></a>连接绑定远程仓库</h2><ul><li><code>git remote add &lt;仓库别名&gt; &lt;address&gt;</code>，其中origin为默认别名，这种方法安全性不高，已被GitHub废除</li></ul><br>- ssh连接：    1. 生成 SSH 密钥        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C &quot;你的邮箱@example.com&quot;</span><br></pre></td></tr></table></figure>        - 看见```Enter file in which to save the key (C:\Users\YSir/.ssh/   id_ed25519):```输入回车表示明文要进入```C:\Users\YSir/.ssh/    id_ed25519```文件夹        <br>        - 看见```Enter passphrase (empty for no passphrase):```设置密码，也可不 设置    <br>    2. 将公钥添加到 GitHub        1. 进入刚刚声明的文件夹，有一个.pub文件，用记事本打开复制里面内容，一般```ssh-ed25519```开头        2. 登录 GitHub → Settings → SSH and GPG keys        3. 点击 "New SSH key"        4. 粘贴公钥内容        <br>    3. 修改远程仓库地址为 SSH        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前远程地址</span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"># 修改为 SSH 地址</span><br><span class="line">git remote set-url origin git@github.com:YSirohhh/Test.git</span><br><span class="line"></span><br><span class="line"># 验证修改</span><br><span class="line">git remote -v       //此时大概率git开头</span><br></pre></td></tr></table></figure>        <br>    4. 测试连接        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>        如果看到 "Hi \<name>! You've successfully authenticated..." 表示成功。        <br>- GitHub CLI(待补充)<h2 id="git交互"><a href="#git交互" class="headerlink" title="git交互"></a>git交互</h2><ol><li><code>git log</code>查看保存节点，可以看到每次提交的信息，加入<code>--stat</code>可以查看具体修改了哪些文件，最重要的是可以依据查询结果的commit值来回溯</li><li><code>git reset --hard [commit值]</code>回溯到指定节点</li><li><code>git checkout [commit值]</code>也可以回溯到指定节点，不过功能比reset强大(待补充)</li><li><code>git push &lt;远程仓库名&gt; [&lt;本地分支名&gt;:&lt;远程分支名&gt;]</code>，一般来说就是<code>git pull origin main</code></li><li><code>git branch</code>查看当前又哪些分支</li><li><code>git checkout -b &lt;分支名&gt;</code>创建分支</li><li><code>git checkout &lt;分支名&gt;</code>切换到分支</li><li><code>git merge &lt;分支名&gt;</code>合并分支</li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
